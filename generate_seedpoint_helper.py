import os
from vtkmodules.vtkCommonColor import vtkNamedColors
from vtkmodules.vtkCommonCore import vtkPoints
from vtkmodules.vtkCommonDataModel import vtkPolyData
from vtkmodules.vtkFiltersCore import vtkGlyph3D
from vtkmodules.vtkFiltersSources import vtkSphereSource
from vtkmodules.vtkRenderingCore import (
    vtkActor,
    vtkPolyDataMapper,
    vtkRenderWindow,
    vtkRenderWindowInteractor,
    vtkRenderer
)

import numpy as np
# from numpy import genfromtxt, cross, linalg as LA
from collections import Counter

from vtk import vtkSimplePointsWriter, vtkTransform, vtkPlaneSource, vtkTransformPolyDataFilter, vtkMaskPoints, vtkArrowSource, vtkDiskSource, vtkTriangleFilter, vtkXMLUnstructuredGridWriter, vtkPolyDataWriter
from vectorfieldtopology_helper import custom_axes 
from vtkmodules.util.numpy_support import numpy_to_vtk, vtk_to_numpy

def generate_seedpoints(infile, outfile, visualize=False):
    """Generate seedpoints with the help of critical points by sampling points around the critical points. 
        :infile: input file with critical points (String)
        :outfile: output file with critical points (String)
    """ 

    # Load data
    data = np.genfromtxt(infile,dtype=float,usecols=[0,1,2])

    # Create point cloud
    points = vtkPoints()
    for x,y,z in data:
        points.InsertNextPoint(x, y, z)


    # Sphere with radius x from the critical point 

    actor, spherical_glyph = get_sphere_around_points_actor(points=points, return_glyph=True)

    if(visualize):
        
        colors = vtkNamedColors()

        # Point cloud
        pointcloud_actor = get_pointcloud_actor(points)
        
        # Add X,Y,Z helper axis
        transform = vtkTransform()
        transform.Translate(25.0, -10.0, 0.0)
        axes = custom_axes(transform)

        renderer = vtkRenderer()
        renderWindow = vtkRenderWindow()
        renderWindow.AddRenderer(renderer)
        renderWindow.SetSize(1920,1080)

        renderWindowInteractor = vtkRenderWindowInteractor()
        renderWindowInteractor.SetRenderWindow(renderWindow)

        renderer.AddActor(actor)
        renderer.AddActor(pointcloud_actor)
        renderer.AddActor(axes)
        renderer.SetBackground(colors.GetColor3d('SlateGray'))  # Background Slate Gray
        
        renderWindow.SetWindowName('Sphere generation')
        renderWindow.Render()
        renderWindowInteractor.Start()

    # Write x,y,z coordinates of critical points
    write_to_file(outfile=outfile, glyph=spherical_glyph)
    write_to_vtk(outfile="spherical_highres.vtk", glyph=spherical_glyph)


def generate_seedpoints_with_plane(infile, critical_point_infile, outfile, visualize=True, show_planes=True, show_normals=True, vectorfield=None):
    """Generate seedpoints with the help of critical points by generating a plane with eigenvectors and sampling on that plane. 
        :infile: input file with jacobian/gradiant (String)
        :critical_point_infile: input file with critical points (String)
        :outfile: Name of output file where seed points will be (String)
        :visualize: To visualize the points or not (Boolean)
        :show_planes: To show plane or not (Boolean)
        :show_normals: To show normal or not (Boolean)
        :vectofield: Takes in a vectorfield. If vectorfield present, it will show in visualization (vtkArrayCalculator())
    """

    # Load data
    data = np.genfromtxt(infile,dtype=float)
    critical_points = np.genfromtxt(critical_point_infile,dtype=float)

    # Find eigenvectors
    plane_vectors = []
    list_of_eigenvectors = []

    for jacobian in data:
        
        eig_val, eig_vec = np.linalg.eig(jacobian.reshape(3,3))
        list_of_eigenvectors.append(eig_vec.tolist())

        # Checks what sign is most common, pos or neg.
        is_pos = Counter(eig_val > 0).most_common(1)[0][0]

        indices = [None,None]
        # Get which indices are of interest
        if(is_pos): indices = [i for i,v in enumerate(eig_val) if v > 0]
        else: indices = [i for i,v in enumerate(eig_val) if v <= 0]

        plane_vectors.append(eig_vec[indices].tolist())

    # List of points and normal vectors that creates the plane
    planes_to_generate = []

    for id, vecs in enumerate(plane_vectors):
        if(len(vecs) > 2): # If all three vectors have the same sign
            vecs.pop()
        v1, v2 = vecs
        point = critical_points[id]

        # the cross product is a vector normal to the plane
        normal = np.cross(v1, v2)
        planes_to_generate.append({
            'point': point.tolist(), 
            'normal': normal.tolist()
        })
    
    # Visualize
    colors = vtkNamedColors()

    # Create point cloud
    points = vtkPoints()
    for x,y,z in critical_points:
        points.InsertNextPoint(x, y, z)

    
    # Plane generated by eigenvectors
    list_of_plane_actors = []
    list_of_polys = []

    for p in planes_to_generate:
        actor, poly = get_disc_actor(p['normal'], p['point'])
        list_of_plane_actors.append(actor)
        list_of_polys.append(poly)

    if(visualize):

        colors = vtkNamedColors()
        # Point cloud
        pointcloud_actor = get_pointcloud_actor(points)
        # Plane normals
        normal_actor = get_plane_normal_actor(points, planes_to_generate)
        
        # Add X,Y,Z helper axis
        transform = vtkTransform()
        transform.Translate(25.0, -10.0, 0.0)
        axes = custom_axes(transform)

        renderer = vtkRenderer()
        renderWindow = vtkRenderWindow()
        renderWindow.AddRenderer(renderer)
        renderWindow.SetSize(1920,1080)

        renderWindowInteractor = vtkRenderWindowInteractor()
        renderWindowInteractor.SetRenderWindow(renderWindow)

        if(show_planes): 
            for a in list_of_plane_actors:
                renderer.AddActor(a)
        if(show_normals): renderer.AddActor(normal_actor)
        if(vectorfield != None):
            renderer.AddActor(get_vectorfield_actor(vectorfield))

        renderer.AddActor(axes)
        renderer.AddActor(pointcloud_actor)
        renderer.SetBackground(colors.GetColor3d('SlateGray'))  # Background Slate Gray
        
        renderWindow.SetWindowName('Plane generation')
        renderWindow.Render()
        renderWindowInteractor.Start()

    # Generate seedpoint files
    write_list_of_poly_to_file(outfile, list_of_polys)
    write_list_of_poly_to_vtk("planes.vtk", list_of_polys)


    



def generate_seedpoints_with_all_eigen_plane(infile, critical_point_infile, outfile, visualize=True, show_planes=True, show_normals=True, vectorfield=None):
    """Generate seedpoints with the help of critical points by generating a plane with eigenvectors and sampling on that plane. 
        :infile: input file with jacobian/gradiant (String)
        :critical_point_infile: input file with critical points (String)
        :outfile: Name of output file where seed points will be (String)
        :visualize: To visualize the points or not (Boolean)
        :show_planes: To show plane or not (Boolean)
        :show_normals: To show normal or not (Boolean)
        :vectofield: Takes in a vectorfield. If vectorfield present, it will show in visualization (vtkArrayCalculator())
    """

    # Load data
    data = np.genfromtxt(infile,dtype=float)
    critical_points = np.genfromtxt(critical_point_infile,dtype=float)

    # Find eigenvectors
    # plane_vectors = []
    list_of_eigenvectors = []

    for jacobian in data:
        
        _, eig_vec = np.linalg.eig(jacobian.reshape(3,3))
        list_of_eigenvectors.append(eig_vec.tolist())


    planes_to_generate = []
    
    # Create point cloud
    points = vtkPoints()
        

    for point, vecs in zip(critical_points, list_of_eigenvectors):

        v1, v2, v3 = vecs

        for vec in vecs: 

            planes_to_generate.append({
                'point': point.tolist(), 
                'normal': vec
            })

            #Add point multiple time.
            points.InsertNextPoint(point[0], point[1], point[2])

    # loop through critical points and go through each of the eigen vectors at that point and generate a plane actor.
    list_of_plane_actors = []
    list_of_polys = []
    for p in planes_to_generate:
        actor, poly = get_disc_actor(p['normal'], p['point'])
        list_of_plane_actors.append(actor)
        list_of_polys.append(poly)

    if(visualize):

        colors = vtkNamedColors()
        # Point cloud
        pointcloud_actor = get_pointcloud_actor(points)
        # Plane normals
        normal_actor = get_plane_normal_actor(points, planes_to_generate)
        
        # Add X,Y,Z helper axis
        transform = vtkTransform()
        transform.Translate(25.0, -10.0, 0.0)
        axes = custom_axes(transform)

        renderer = vtkRenderer()
        renderWindow = vtkRenderWindow()
        renderWindow.AddRenderer(renderer)
        renderWindow.SetSize(1920,1080)

        renderWindowInteractor = vtkRenderWindowInteractor()
        renderWindowInteractor.SetRenderWindow(renderWindow)

        if(show_planes): 
            for a in list_of_plane_actors:
                renderer.AddActor(a)
        if(show_normals): renderer.AddActor(normal_actor)
        if(vectorfield != None):
            renderer.AddActor(get_vectorfield_actor(vectorfield))

        renderer.AddActor(axes)
        renderer.AddActor(pointcloud_actor)
        renderer.SetBackground(colors.GetColor3d('SlateGray'))  # Background Slate Gray
        
        renderWindow.SetWindowName('Plane generation')
        renderWindow.Render()
        renderWindowInteractor.Start()

    # Generate seedpoint files
    write_list_of_poly_to_file(outfile, list_of_polys)
    write_list_of_poly_to_vtk("eigen_vec_as_normal_plane_highres.vtk", list_of_polys)


def get_disc_actor(normal, point):
    colors = vtkNamedColors()

    # Default is (0,0,1)
    diskSource = vtkDiskSource()
    diskSource.SetInnerRadius(0.01)
    diskSource.SetOuterRadius(0.5)
    diskSource.SetRadialResolution(2)
    diskSource.SetCircumferentialResolution(12)

    matrix = rotation_matrix_from_vectors([0,0,1], normal)

    # Transformer
    transform = vtkTransform()
    transform.PreMultiply()
    transform.SetMatrix(matrix.real.flatten())
    transform.PostMultiply()
    # transform.RotateX(20)
    transform.Translate(point[0], point[1], point[2])
    transform.Update()

    transformFilter = vtkTransformPolyDataFilter()
    transformFilter.SetTransform(transform)
    transformFilter.SetInputConnection(diskSource.GetOutputPort())
    transformFilter.Update()

    # Create a mapper and actor.
    mapper = vtkPolyDataMapper()
    mapper.SetInputConnection(transformFilter.GetOutputPort())

    actor = vtkActor()
    actor.GetProperty().SetColor(colors.GetColor3d("Yellow"))
    actor.SetMapper(mapper)

    return actor, transformFilter.GetOutput()

def rotation_matrix_from_vectors(vec1, vec2):
    """ Find the rotation matrix that aligns vec1 to vec2
    :param vec1: A 3d "source" vector
    :param vec2: A 3d "destination" vector
    :return mat: A transform matrix (4x4) which when applied to vec1, aligns it with vec2.
    """

    vec1 = np.array(vec1).real
    vec2 = np.array(vec2).real

    a, b = (vec1 / np.linalg.norm(vec1)).reshape(3), (vec2 / np.linalg.norm(vec2)).reshape(3)
    v = np.cross(a, b)
    c = np.dot(a, b)
    s = np.linalg.norm(v)
    kmat = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])
    rotation_matrix = np.eye(3) + kmat + kmat.dot(kmat) * ((1 - c) / (s ** 2))
    rotation_matrix = np.c_[rotation_matrix, np.zeros(3)] # Add zeros column
    rotation_matrix = np.r_[rotation_matrix, [[0,0,0,1]]] # Add zeros column

    return rotation_matrix













def write_to_vtk(outfile, glyph):
    writer = vtkPolyDataWriter()
    writer.SetInputData(glyph.GetOutput())
    writer.SetFileName(outfile)
    writer.Update()

    print(f"Saved seed point structure as .vtu at: '{outfile}'")

def write_to_file(outfile, glyph):
    """Writes the glyph data into a file
        :outfile: Name of the file you want to write the file to (String)
        :glyph: Glyph containing the array data you want to save (vtkGlyph3D())
    """

    # # Write x,y,z coordinates of critical points
    writer = vtkSimplePointsWriter()
    writer.SetDecimalPrecision(5)
    writer.SetFileName(outfile)
    writer.SetInputConnection(glyph.GetOutputPort(0))
    writer.Write()

    print(f"Generated {glyph.GetOutput().GetPointData().GetNumberOfTuples()} seed points in file: '{outfile}'")

def write_poly_to_file(outfile, poly):
    """Writes the glyph data into a file
        :outfile: Name of the file you want to write the file to (String)
        :poly: PolyData containing the array data you want to save (vtkPolyData())
    """

    # Write x,y,z coordinates of critical points
    writer = vtkSimplePointsWriter()
    writer.SetDecimalPrecision(5)
    writer.SetFileName(outfile)
    writer.SetInputData(poly)
    writer.Write()

    print(f"Generated {poly.GetNumberOfPoints()} seed points in file: '{outfile}'")


def write_list_of_poly_to_file(outfile, list_of_polys):

    all_points = vtkPoints()

    for poly in list_of_polys:
        for p in vtk_to_numpy(poly.GetPoints().GetData()):
            all_points.InsertNextPoint(p[0],p[1],p[2])

    cp_polydata = vtkPolyData()
    cp_polydata.SetPoints(all_points)
    
    write_poly_to_file(outfile, cp_polydata)

def write_list_of_poly_to_vtk(outfile, list_of_polys):
    all_points = vtkPoints()

    for poly in list_of_polys:
        for p in vtk_to_numpy(poly.GetPoints().GetData()):
            all_points.InsertNextPoint(p[0],p[1],p[2])

    cp_polydata = vtkPolyData()
    cp_polydata.SetPoints(all_points)

    print(f"Saved seed point structure as .vtu at: '{outfile}'")


def get_plane_normal_actor(points, planes):
    """Returns the actor (vtkRenderingOpenGL) of the normal of the given planes
        :points: Points where the normal vector lies (vtkPoint())
        :planes: List of plane objects [{"point": [x1,y1,z1], "normal": [x2,y2,z2]}]
    """

    colors = vtkNamedColors()

    plane_normal_polydata = vtkPolyData()
    plane_normal_polydata.SetPoints(points)

    # Generate normal vectors to see how it is pointed
    arrayOfNormals = np.array([np.array(p['normal']).real for p in planes])
    plane_normal_polydata.GetPointData().SetNormals(numpy_to_vtk(arrayOfNormals))

    # Create a plane
    normalArrowSource = vtkArrowSource()
    normalArrowSource.Update()

    # Create 3d glyph to map the plane with pointdata
    normalGlyph = vtkGlyph3D()
    normalGlyph.SetInputData(plane_normal_polydata)
    normalGlyph.SetSourceConnection(normalArrowSource.GetOutputPort())
    normalGlyph.SetVectorModeToUseNormal()
    normalGlyph.SetScaleFactor(2)
    normalGlyph.Update()

    # Create a mapper and actor
    normalMapper = vtkPolyDataMapper()
    normalMapper.SetInputData(normalGlyph.GetOutput())

    normalActor = vtkActor()
    normalActor.SetMapper(normalMapper)
    normalActor.GetProperty().SetColor(colors.GetColor3d('Yellow'))
    normalActor.GetProperty().SetOpacity(1)
    # normalActor.GetProperty().SetRepresentationToWireframe()

    return normalActor

def get_eigenvector_plane_actor(points, plane_vectors, return_glyph=True, eigen_as_normal=False, rad_resoulation=4, cir_resolution=12, scale=2, inner_rad=0.01, outer_rad=0.5):
    """Returns the actor (vtkRenderingOpenGL) of the normal of the given planes vectors. Returns glyph data if wanted.
        :points: Points where the normal vector lies (vtkPoint())
        :plane_vectors: List of eigen vectors building up the plane ([[v1,w1],..,[vn,wn]])
    """

    plane_polydata = vtkPolyData()
    plane_polydata.SetPoints(points)

    # Generate vectors perpendicular to normal so the plane lays correctly
    # arrayOfPerpNormals = np.array([perpendicular_vector(np.array(p['normal'])).real for p in planes])

    if(eigen_as_normal):
      
        arrayOfPerpNormals = []
        
        for p in plane_vectors:
            for vec in p:
                arrayOfPerpNormals.append(np.array(vec).real)
        
        arrayOfPerpNormals = np.array(arrayOfPerpNormals)
        print("eigen as normal",len(arrayOfPerpNormals))

        plane_polydata.GetPointData().SetNormals(numpy_to_vtk(arrayOfPerpNormals))
    else:
        arrayOfPerpNormals = np.array([np.array(p)[0].real for p in plane_vectors])
        plane_polydata.GetPointData().SetNormals(numpy_to_vtk(arrayOfPerpNormals))
        print("reg normal",len(arrayOfPerpNormals))


    # Create a pentagon
    planeSource = vtkDiskSource()
    planeSource.SetInnerRadius(inner_rad)
    planeSource.SetOuterRadius(outer_rad)
    planeSource.SetRadialResolution(rad_resoulation)
    planeSource.SetCircumferentialResolution(cir_resolution)

    # Create 3d glyph to map the plane with pointdata
    glyph = vtkGlyph3D()
    glyph.SetInputData(plane_polydata)
    glyph.SetSourceConnection(planeSource.GetOutputPort())
    glyph.SetVectorModeToUseNormal()
    glyph.SetScaleFactor(scale)
    glyph.Update()

    # Create a mapper and actor
    mapper = vtkPolyDataMapper()
    mapper.SetInputData(glyph.GetOutput())

    actor = vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetColor(0.,0.,0.)
    actor.GetProperty().SetOpacity(0.5)
    actor.GetProperty().SetRepresentationToWireframe()
    # actor.GetProperty().SetRepresentationToPoints()
    actor.GetProperty().SetRenderPointsAsSpheres(True)

    if(return_glyph):
        return(actor, glyph)

    return actor

def get_pointcloud_actor(points):
    """Returns the actor (vtkRenderingOpenGL) of the points given
        :points: Points where the critical points lies (vtkPoint())
    """
    
    cp_polydata = vtkPolyData()
    cp_polydata.SetPoints(points)

    pointSource = vtkSphereSource()
    pointSource.SetThetaResolution(10)
    pointSource.SetPhiResolution(10)
    pointSource.SetRadius(0.1)

    pGlyph3D = vtkGlyph3D()
    pGlyph3D.SetSourceConnection(pointSource.GetOutputPort())
    pGlyph3D.SetInputData(cp_polydata)
    pGlyph3D.Update()

    # Visualize
    pMapper = vtkPolyDataMapper()
    pMapper.SetInputConnection(pGlyph3D.GetOutputPort())

    pActor = vtkActor()
    pActor.SetMapper(pMapper)
    pActor.GetProperty().SetColor(0.,0.,0.)
    return pActor

def get_sphere_around_points_actor(points, return_glyph=True):
    """Returns the actor (vtkRenderingOpenGL) of the sphere surrounding a point. Returns glyph data if wanted.
        :points: Points where the normal vector lies (vtkPoint())
        :plane_vectors: List of eigen vectors building up the plane ([[v1,w1],..,[vn,wn]])
    """

    colors = vtkNamedColors()

    polydata = vtkPolyData()
    polydata.SetPoints(points)

    sphereSource = vtkSphereSource()
    sphereSource.SetThetaResolution(3)
    sphereSource.SetPhiResolution(3)
    sphereSource.SetRadius(1)

    glyph3D = vtkGlyph3D()
    glyph3D.SetSourceConnection(sphereSource.GetOutputPort())
    glyph3D.SetInputData(polydata)
    glyph3D.Update()

    # Visualize seed points
    mapper = vtkPolyDataMapper()
    mapper.SetInputConnection(glyph3D.GetOutputPort())

    actor = vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetColor(colors.GetColor3d('Salmon'))
    actor.GetProperty().SetOpacity(0.5)
    actor.GetProperty().SetRepresentationToWireframe()

    if(return_glyph):
        return (actor, glyph3D)
    
    return actor

def get_vectorfield_actor(vectorfield):
    """Returns the actor (vtkRenderingOpenGL) of the vectorfield
        :vectofield: Takes in a vectorfield (vtkArrayCalculator())
    """
    
    # Create the glyphs source
    arrowSource = vtkArrowSource()

    # Create the mask (not wanting every single value)
    ptMask = vtkMaskPoints()
    ptMask.SetInputConnection(vectorfield.GetOutputPort())
    ptMask.RandomModeOn()
    ptMask.SetMaximumNumberOfPoints(1000)

    # Create 3D Glyphs
    glyph3D = vtkGlyph3D()
    glyph3D.SetSourceConnection(arrowSource.GetOutputPort())
    glyph3D.SetInputConnection(ptMask.GetOutputPort())
    glyph3D.SetVectorModeToUseVector()
    
    glyph3D.SetScaleFactor(1)
    glyph3D.Update()

    # Visualize
    mapper = vtkPolyDataMapper()
    mapper.SetInputConnection(glyph3D.GetOutputPort())

    actor = vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetColor(0,0,0)
    actor.GetProperty().SetOpacity(0.2)

    return actor

def perpendicular_vector(v):
    """Returns a perpendicular vector
        :v: vector ([x,y,z])
    """
    if v[1] == 0 and v[2] == 0:
        if v[0] == 0:
            raise ValueError('zero vector')
        else:
            return np.cross(v, [0, 1, 0])
    return np.cross(v, [1, 0, 0])





